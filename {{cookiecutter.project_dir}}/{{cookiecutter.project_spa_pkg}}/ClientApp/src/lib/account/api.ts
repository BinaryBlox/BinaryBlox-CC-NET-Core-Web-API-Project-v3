/* tslint:disable */
/* eslint-disable */
/**
 * Generated Account API
 * A Generated Account API Microservice with versioning.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: {{cookiecutter.author_email}}
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AddApplicationClientUserMapViewModel
 */
export interface AddApplicationClientUserMapViewModel {
    /**
     * 
     * @type {string}
     * @memberof AddApplicationClientUserMapViewModel
     */
    userId: string;
    /**
     * 
     * @type {number}
     * @memberof AddApplicationClientUserMapViewModel
     */
    clientId: number;
}
/**
 * 
 * @export
 * @interface AddApplicationClientViewModel
 */
export interface AddApplicationClientViewModel {
    /**
     * 
     * @type {string}
     * @memberof AddApplicationClientViewModel
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof AddApplicationClientViewModel
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof AddApplicationClientViewModel
     */
    thumbImageUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddApplicationClientViewModel
     */
    imageUrl?: string | null;
}
/**
 * 
 * @export
 * @interface ApplicationClientUserMapViewModel
 */
export interface ApplicationClientUserMapViewModel {
    /**
     * 
     * @type {number}
     * @memberof ApplicationClientUserMapViewModel
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationClientUserMapViewModel
     */
    guidId: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationClientUserMapViewModel
     */
    userId: string;
    /**
     * 
     * @type {number}
     * @memberof ApplicationClientUserMapViewModel
     */
    clientId: number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationClientUserMapViewModel
     */
    userEmail?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationClientUserMapViewModel
     */
    clientName?: string | null;
}
/**
 * 
 * @export
 * @interface ApplicationClientViewModel
 */
export interface ApplicationClientViewModel {
    /**
     * 
     * @type {number}
     * @memberof ApplicationClientViewModel
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationClientViewModel
     */
    guidId: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationClientViewModel
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationClientViewModel
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationClientViewModel
     */
    thumbImageUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationClientViewModel
     */
    imageUrl?: string | null;
}
/**
 * 
 * @export
 * @interface CreateUserViewModel
 */
export interface CreateUserViewModel {
    /**
     * 
     * @type {string}
     * @memberof CreateUserViewModel
     */
    email?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateUserViewModel
     */
    username?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateUserViewModel
     */
    password?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateUserViewModel
     */
    givenName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateUserViewModel
     */
    familyName?: string | null;
}
/**
 * 
 * @export
 * @interface ExternalLoginViewModel
 */
export interface ExternalLoginViewModel {
    /**
     * 
     * @type {string}
     * @memberof ExternalLoginViewModel
     */
    email: string;
}
/**
 * 
 * @export
 * @interface LoginViewModel
 */
export interface LoginViewModel {
    /**
     * 
     * @type {string}
     * @memberof LoginViewModel
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof LoginViewModel
     */
    password: string;
    /**
     * 
     * @type {boolean}
     * @memberof LoginViewModel
     */
    rememberMe?: boolean;
}
/**
 * 
 * @export
 * @interface LoginWith2faViewModel
 */
export interface LoginWith2faViewModel {
    /**
     * 
     * @type {string}
     * @memberof LoginWith2faViewModel
     */
    twoFactorCode: string;
    /**
     * 
     * @type {boolean}
     * @memberof LoginWith2faViewModel
     */
    rememberMachine?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LoginWith2faViewModel
     */
    rememberMe?: boolean;
}
/**
 * 
 * @export
 * @interface LoginWithRecoveryCodeViewModel
 */
export interface LoginWithRecoveryCodeViewModel {
    /**
     * 
     * @type {string}
     * @memberof LoginWithRecoveryCodeViewModel
     */
    recoveryCode: string;
}
/**
 * 
 * @export
 * @interface PermissionViewModel
 */
export interface PermissionViewModel {
    /**
     * 
     * @type {string}
     * @memberof PermissionViewModel
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PermissionViewModel
     */
    value?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PermissionViewModel
     */
    groupName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PermissionViewModel
     */
    description?: string | null;
}
/**
 * 
 * @export
 * @interface ProblemDetails
 */
export interface ProblemDetails {
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    type?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    title?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ProblemDetails
     */
    status?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    detail?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    instance?: string | null;
    /**
     *  
     * @memberof ProblemDetails
     */
    extensions?: { [key: string]: object; } | null;
}
/**
 * 
 * @export
 * @interface RegisterViewModel
 */
export interface RegisterViewModel {
    /**
     * 
     * @type {string}
     * @memberof RegisterViewModel
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterViewModel
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterViewModel
     */
    confirmPassword?: string | null;
}
/**
 * 
 * @export
 * @interface ResetPasswordViewModel
 */
export interface ResetPasswordViewModel {
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordViewModel
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordViewModel
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordViewModel
     */
    confirmPassword?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordViewModel
     */
    code?: string | null;
}
/**
 * 
 * @export
 * @interface RoleViewModel
 */
export interface RoleViewModel {
    /**
     * 
     * @type {string}
     * @memberof RoleViewModel
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RoleViewModel
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RoleViewModel
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof RoleViewModel
     */
    usersCount?: number;
    /**
     * 
     * @type {Array<PermissionViewModel>}
     * @memberof RoleViewModel
     */
    permissions?: Array<PermissionViewModel> | null;
}
/**
 * 
 * @export
 * @interface UserEditViewModel
 */
export interface UserEditViewModel {
    /**
     * 
     * @type {string}
     * @memberof UserEditViewModel
     */
    userName: string;
    /**
     * 
     * @type {string}
     * @memberof UserEditViewModel
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof UserEditViewModel
     */
    currentPassword?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserEditViewModel
     */
    newPassword?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserEditViewModel
     */
    isLockedOut?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserEditViewModel
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserEditViewModel
     */
    fullName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserEditViewModel
     */
    jobTitle?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserEditViewModel
     */
    phoneNumber?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserEditViewModel
     */
    configuration?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserEditViewModel
     */
    isEnabled?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserEditViewModel
     */
    roles?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface UserPatchViewModelJsonPatchDocument
 */
export interface UserPatchViewModelJsonPatchDocument {
    /**
     * 
     * @type {Array<UserPatchViewModelOperation>}
     * @memberof UserPatchViewModelJsonPatchDocument
     */
    operations?: Array<UserPatchViewModelOperation> | null;
}
/**
 * 
 * @export
 * @interface UserPatchViewModelOperation
 */
export interface UserPatchViewModelOperation {
    /**
     * 
     * @type {object}
     * @memberof UserPatchViewModelOperation
     */
    value?: object | null;
    /**
     * 
     * @type {string}
     * @memberof UserPatchViewModelOperation
     */
    path?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserPatchViewModelOperation
     */
    op?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserPatchViewModelOperation
     */
    from?: string | null;
}
/**
 * 
 * @export
 * @interface UserViewModel
 */
export interface UserViewModel {
    /**
     * 
     * @type {string}
     * @memberof UserViewModel
     */
    userName: string;
    /**
     * 
     * @type {string}
     * @memberof UserViewModel
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof UserViewModel
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserViewModel
     */
    fullName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserViewModel
     */
    jobTitle?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserViewModel
     */
    phoneNumber?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserViewModel
     */
    configuration?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserViewModel
     */
    isEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserViewModel
     */
    isLockedOut?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserViewModel
     */
    roles?: Array<string> | null;
}

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountPermissionsGet: async (apiVersion: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling apiAccountPermissionsGet.');
            }
            const localVarPath = `/api/Account/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {CreateUserViewModel} [createUserViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountRegisterPost: async (apiVersion: string, createUserViewModel?: CreateUserViewModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling apiAccountRegisterPost.');
            }
            const localVarPath = `/api/Account/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof createUserViewModel !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(createUserViewModel !== undefined ? createUserViewModel : {})
                : (createUserViewModel || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountRolesGet: async (apiVersion: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling apiAccountRolesGet.');
            }
            const localVarPath = `/api/Account/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountRolesIdDelete: async (id: string, apiVersion: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiAccountRolesIdDelete.');
            }
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling apiAccountRolesIdDelete.');
            }
            const localVarPath = `/api/Account/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} apiVersion The requested API version
         * @param {RoleViewModel} [roleViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountRolesIdPut: async (id: string, apiVersion: string, roleViewModel?: RoleViewModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiAccountRolesIdPut.');
            }
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling apiAccountRolesIdPut.');
            }
            const localVarPath = `/api/Account/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof roleViewModel !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(roleViewModel !== undefined ? roleViewModel : {})
                : (roleViewModel || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountRolesNameNameGet: async (name: string, apiVersion: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling apiAccountRolesNameNameGet.');
            }
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling apiAccountRolesNameNameGet.');
            }
            const localVarPath = `/api/Account/roles/name/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} pageNumber 
         * @param {number} pageSize 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountRolesPageNumberPageSizeGet: async (pageNumber: number, pageSize: number, apiVersion: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageNumber' is not null or undefined
            if (pageNumber === null || pageNumber === undefined) {
                throw new RequiredError('pageNumber','Required parameter pageNumber was null or undefined when calling apiAccountRolesPageNumberPageSizeGet.');
            }
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling apiAccountRolesPageNumberPageSizeGet.');
            }
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling apiAccountRolesPageNumberPageSizeGet.');
            }
            const localVarPath = `/api/Account/roles/{pageNumber}/{pageSize}`
                .replace(`{${"pageNumber"}}`, encodeURIComponent(String(pageNumber)))
                .replace(`{${"pageSize"}}`, encodeURIComponent(String(pageSize)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {RoleViewModel} [roleViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountRolesPost: async (apiVersion: string, roleViewModel?: RoleViewModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling apiAccountRolesPost.');
            }
            const localVarPath = `/api/Account/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof roleViewModel !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(roleViewModel !== undefined ? roleViewModel : {})
                : (roleViewModel || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountUsersGet: async (apiVersion: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling apiAccountUsersGet.');
            }
            const localVarPath = `/api/Account/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountUsersIdDelete: async (id: string, apiVersion: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiAccountUsersIdDelete.');
            }
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling apiAccountUsersIdDelete.');
            }
            const localVarPath = `/api/Account/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} apiVersion The requested API version
         * @param {UserPatchViewModelJsonPatchDocument} [userPatchViewModelJsonPatchDocument] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountUsersIdPatch: async (id: string, apiVersion: string, userPatchViewModelJsonPatchDocument?: UserPatchViewModelJsonPatchDocument, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiAccountUsersIdPatch.');
            }
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling apiAccountUsersIdPatch.');
            }
            const localVarPath = `/api/Account/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof userPatchViewModelJsonPatchDocument !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(userPatchViewModelJsonPatchDocument !== undefined ? userPatchViewModelJsonPatchDocument : {})
                : (userPatchViewModelJsonPatchDocument || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} apiVersion The requested API version
         * @param {UserEditViewModel} [userEditViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountUsersIdPut: async (id: string, apiVersion: string, userEditViewModel?: UserEditViewModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiAccountUsersIdPut.');
            }
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling apiAccountUsersIdPut.');
            }
            const localVarPath = `/api/Account/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof userEditViewModel !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(userEditViewModel !== undefined ? userEditViewModel : {})
                : (userEditViewModel || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountUsersMeGet: async (apiVersion: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling apiAccountUsersMeGet.');
            }
            const localVarPath = `/api/Account/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {UserPatchViewModelJsonPatchDocument} [userPatchViewModelJsonPatchDocument] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountUsersMePatch: async (apiVersion: string, userPatchViewModelJsonPatchDocument?: UserPatchViewModelJsonPatchDocument, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling apiAccountUsersMePatch.');
            }
            const localVarPath = `/api/Account/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof userPatchViewModelJsonPatchDocument !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(userPatchViewModelJsonPatchDocument !== undefined ? userPatchViewModelJsonPatchDocument : {})
                : (userPatchViewModelJsonPatchDocument || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountUsersMePreferencesGet: async (apiVersion: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling apiAccountUsersMePreferencesGet.');
            }
            const localVarPath = `/api/Account/users/me/preferences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountUsersMePreferencesPut: async (apiVersion: string, body?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling apiAccountUsersMePreferencesPut.');
            }
            const localVarPath = `/api/Account/users/me/preferences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {UserEditViewModel} [userEditViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountUsersMePut: async (apiVersion: string, userEditViewModel?: UserEditViewModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling apiAccountUsersMePut.');
            }
            const localVarPath = `/api/Account/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof userEditViewModel !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(userEditViewModel !== undefined ? userEditViewModel : {})
                : (userEditViewModel || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} pageNumber 
         * @param {number} pageSize 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountUsersPageNumberPageSizeGet: async (pageNumber: number, pageSize: number, apiVersion: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageNumber' is not null or undefined
            if (pageNumber === null || pageNumber === undefined) {
                throw new RequiredError('pageNumber','Required parameter pageNumber was null or undefined when calling apiAccountUsersPageNumberPageSizeGet.');
            }
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling apiAccountUsersPageNumberPageSizeGet.');
            }
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling apiAccountUsersPageNumberPageSizeGet.');
            }
            const localVarPath = `/api/Account/users/{pageNumber}/{pageSize}`
                .replace(`{${"pageNumber"}}`, encodeURIComponent(String(pageNumber)))
                .replace(`{${"pageSize"}}`, encodeURIComponent(String(pageSize)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {UserEditViewModel} [userEditViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountUsersPost: async (apiVersion: string, userEditViewModel?: UserEditViewModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling apiAccountUsersPost.');
            }
            const localVarPath = `/api/Account/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof userEditViewModel !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(userEditViewModel !== undefined ? userEditViewModel : {})
                : (userEditViewModel || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountUsersUnblockIdPut: async (id: string, apiVersion: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiAccountUsersUnblockIdPut.');
            }
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling apiAccountUsersUnblockIdPut.');
            }
            const localVarPath = `/api/Account/users/unblock/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userName 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountUsersUsernameUserNameGet: async (userName: string, apiVersion: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userName' is not null or undefined
            if (userName === null || userName === undefined) {
                throw new RequiredError('userName','Required parameter userName was null or undefined when calling apiAccountUsersUsernameUserNameGet.');
            }
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling apiAccountUsersUsernameUserNameGet.');
            }
            const localVarPath = `/api/Account/users/username/{userName}`
                .replace(`{${"userName"}}`, encodeURIComponent(String(userName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleById: async (id: string, apiVersion: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRoleById.');
            }
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling getRoleById.');
            }
            const localVarPath = `/api/Account/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (id: string, apiVersion: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getUserById.');
            }
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling getUserById.');
            }
            const localVarPath = `/api/Account/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountPermissionsGet(apiVersion: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PermissionViewModel>>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).apiAccountPermissionsGet(apiVersion, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {CreateUserViewModel} [createUserViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountRegisterPost(apiVersion: string, createUserViewModel?: CreateUserViewModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserViewModel>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).apiAccountRegisterPost(apiVersion, createUserViewModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountRolesGet(apiVersion: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleViewModel>>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).apiAccountRolesGet(apiVersion, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountRolesIdDelete(id: string, apiVersion: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleViewModel>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).apiAccountRolesIdDelete(id, apiVersion, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} apiVersion The requested API version
         * @param {RoleViewModel} [roleViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountRolesIdPut(id: string, apiVersion: string, roleViewModel?: RoleViewModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).apiAccountRolesIdPut(id, apiVersion, roleViewModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountRolesNameNameGet(name: string, apiVersion: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleViewModel>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).apiAccountRolesNameNameGet(name, apiVersion, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} pageNumber 
         * @param {number} pageSize 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountRolesPageNumberPageSizeGet(pageNumber: number, pageSize: number, apiVersion: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleViewModel>>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).apiAccountRolesPageNumberPageSizeGet(pageNumber, pageSize, apiVersion, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {RoleViewModel} [roleViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountRolesPost(apiVersion: string, roleViewModel?: RoleViewModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleViewModel>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).apiAccountRolesPost(apiVersion, roleViewModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountUsersGet(apiVersion: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserViewModel>>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).apiAccountUsersGet(apiVersion, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountUsersIdDelete(id: string, apiVersion: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserViewModel>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).apiAccountUsersIdDelete(id, apiVersion, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} apiVersion The requested API version
         * @param {UserPatchViewModelJsonPatchDocument} [userPatchViewModelJsonPatchDocument] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountUsersIdPatch(id: string, apiVersion: string, userPatchViewModelJsonPatchDocument?: UserPatchViewModelJsonPatchDocument, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).apiAccountUsersIdPatch(id, apiVersion, userPatchViewModelJsonPatchDocument, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} apiVersion The requested API version
         * @param {UserEditViewModel} [userEditViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountUsersIdPut(id: string, apiVersion: string, userEditViewModel?: UserEditViewModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).apiAccountUsersIdPut(id, apiVersion, userEditViewModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountUsersMeGet(apiVersion: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserViewModel>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).apiAccountUsersMeGet(apiVersion, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {UserPatchViewModelJsonPatchDocument} [userPatchViewModelJsonPatchDocument] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountUsersMePatch(apiVersion: string, userPatchViewModelJsonPatchDocument?: UserPatchViewModelJsonPatchDocument, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).apiAccountUsersMePatch(apiVersion, userPatchViewModelJsonPatchDocument, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountUsersMePreferencesGet(apiVersion: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).apiAccountUsersMePreferencesGet(apiVersion, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountUsersMePreferencesPut(apiVersion: string, body?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).apiAccountUsersMePreferencesPut(apiVersion, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {UserEditViewModel} [userEditViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountUsersMePut(apiVersion: string, userEditViewModel?: UserEditViewModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).apiAccountUsersMePut(apiVersion, userEditViewModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} pageNumber 
         * @param {number} pageSize 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountUsersPageNumberPageSizeGet(pageNumber: number, pageSize: number, apiVersion: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserViewModel>>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).apiAccountUsersPageNumberPageSizeGet(pageNumber, pageSize, apiVersion, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {UserEditViewModel} [userEditViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountUsersPost(apiVersion: string, userEditViewModel?: UserEditViewModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserViewModel>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).apiAccountUsersPost(apiVersion, userEditViewModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountUsersUnblockIdPut(id: string, apiVersion: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).apiAccountUsersUnblockIdPut(id, apiVersion, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userName 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountUsersUsernameUserNameGet(userName: string, apiVersion: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserViewModel>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).apiAccountUsersUsernameUserNameGet(userName, apiVersion, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleById(id: string, apiVersion: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleViewModel>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).getRoleById(id, apiVersion, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(id: string, apiVersion: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserViewModel>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).getUserById(id, apiVersion, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountPermissionsGet(apiVersion: string, options?: any): AxiosPromise<Array<PermissionViewModel>> {
            return AccountApiFp(configuration).apiAccountPermissionsGet(apiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {CreateUserViewModel} [createUserViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountRegisterPost(apiVersion: string, createUserViewModel?: CreateUserViewModel, options?: any): AxiosPromise<UserViewModel> {
            return AccountApiFp(configuration).apiAccountRegisterPost(apiVersion, createUserViewModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountRolesGet(apiVersion: string, options?: any): AxiosPromise<Array<RoleViewModel>> {
            return AccountApiFp(configuration).apiAccountRolesGet(apiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountRolesIdDelete(id: string, apiVersion: string, options?: any): AxiosPromise<RoleViewModel> {
            return AccountApiFp(configuration).apiAccountRolesIdDelete(id, apiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} apiVersion The requested API version
         * @param {RoleViewModel} [roleViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountRolesIdPut(id: string, apiVersion: string, roleViewModel?: RoleViewModel, options?: any): AxiosPromise<void> {
            return AccountApiFp(configuration).apiAccountRolesIdPut(id, apiVersion, roleViewModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountRolesNameNameGet(name: string, apiVersion: string, options?: any): AxiosPromise<RoleViewModel> {
            return AccountApiFp(configuration).apiAccountRolesNameNameGet(name, apiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} pageNumber 
         * @param {number} pageSize 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountRolesPageNumberPageSizeGet(pageNumber: number, pageSize: number, apiVersion: string, options?: any): AxiosPromise<Array<RoleViewModel>> {
            return AccountApiFp(configuration).apiAccountRolesPageNumberPageSizeGet(pageNumber, pageSize, apiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {RoleViewModel} [roleViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountRolesPost(apiVersion: string, roleViewModel?: RoleViewModel, options?: any): AxiosPromise<RoleViewModel> {
            return AccountApiFp(configuration).apiAccountRolesPost(apiVersion, roleViewModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountUsersGet(apiVersion: string, options?: any): AxiosPromise<Array<UserViewModel>> {
            return AccountApiFp(configuration).apiAccountUsersGet(apiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountUsersIdDelete(id: string, apiVersion: string, options?: any): AxiosPromise<UserViewModel> {
            return AccountApiFp(configuration).apiAccountUsersIdDelete(id, apiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} apiVersion The requested API version
         * @param {UserPatchViewModelJsonPatchDocument} [userPatchViewModelJsonPatchDocument] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountUsersIdPatch(id: string, apiVersion: string, userPatchViewModelJsonPatchDocument?: UserPatchViewModelJsonPatchDocument, options?: any): AxiosPromise<void> {
            return AccountApiFp(configuration).apiAccountUsersIdPatch(id, apiVersion, userPatchViewModelJsonPatchDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} apiVersion The requested API version
         * @param {UserEditViewModel} [userEditViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountUsersIdPut(id: string, apiVersion: string, userEditViewModel?: UserEditViewModel, options?: any): AxiosPromise<void> {
            return AccountApiFp(configuration).apiAccountUsersIdPut(id, apiVersion, userEditViewModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountUsersMeGet(apiVersion: string, options?: any): AxiosPromise<UserViewModel> {
            return AccountApiFp(configuration).apiAccountUsersMeGet(apiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {UserPatchViewModelJsonPatchDocument} [userPatchViewModelJsonPatchDocument] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountUsersMePatch(apiVersion: string, userPatchViewModelJsonPatchDocument?: UserPatchViewModelJsonPatchDocument, options?: any): AxiosPromise<void> {
            return AccountApiFp(configuration).apiAccountUsersMePatch(apiVersion, userPatchViewModelJsonPatchDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountUsersMePreferencesGet(apiVersion: string, options?: any): AxiosPromise<string> {
            return AccountApiFp(configuration).apiAccountUsersMePreferencesGet(apiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountUsersMePreferencesPut(apiVersion: string, body?: string, options?: any): AxiosPromise<void> {
            return AccountApiFp(configuration).apiAccountUsersMePreferencesPut(apiVersion, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {UserEditViewModel} [userEditViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountUsersMePut(apiVersion: string, userEditViewModel?: UserEditViewModel, options?: any): AxiosPromise<void> {
            return AccountApiFp(configuration).apiAccountUsersMePut(apiVersion, userEditViewModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} pageNumber 
         * @param {number} pageSize 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountUsersPageNumberPageSizeGet(pageNumber: number, pageSize: number, apiVersion: string, options?: any): AxiosPromise<Array<UserViewModel>> {
            return AccountApiFp(configuration).apiAccountUsersPageNumberPageSizeGet(pageNumber, pageSize, apiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {UserEditViewModel} [userEditViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountUsersPost(apiVersion: string, userEditViewModel?: UserEditViewModel, options?: any): AxiosPromise<UserViewModel> {
            return AccountApiFp(configuration).apiAccountUsersPost(apiVersion, userEditViewModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountUsersUnblockIdPut(id: string, apiVersion: string, options?: any): AxiosPromise<void> {
            return AccountApiFp(configuration).apiAccountUsersUnblockIdPut(id, apiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userName 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountUsersUsernameUserNameGet(userName: string, apiVersion: string, options?: any): AxiosPromise<UserViewModel> {
            return AccountApiFp(configuration).apiAccountUsersUsernameUserNameGet(userName, apiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleById(id: string, apiVersion: string, options?: any): AxiosPromise<RoleViewModel> {
            return AccountApiFp(configuration).getRoleById(id, apiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(id: string, apiVersion: string, options?: any): AxiosPromise<UserViewModel> {
            return AccountApiFp(configuration).getUserById(id, apiVersion, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public apiAccountPermissionsGet(apiVersion: string, options?: any) {
        return AccountApiFp(this.configuration).apiAccountPermissionsGet(apiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {CreateUserViewModel} [createUserViewModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public apiAccountRegisterPost(apiVersion: string, createUserViewModel?: CreateUserViewModel, options?: any) {
        return AccountApiFp(this.configuration).apiAccountRegisterPost(apiVersion, createUserViewModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public apiAccountRolesGet(apiVersion: string, options?: any) {
        return AccountApiFp(this.configuration).apiAccountRolesGet(apiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} apiVersion The requested API version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public apiAccountRolesIdDelete(id: string, apiVersion: string, options?: any) {
        return AccountApiFp(this.configuration).apiAccountRolesIdDelete(id, apiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} apiVersion The requested API version
     * @param {RoleViewModel} [roleViewModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public apiAccountRolesIdPut(id: string, apiVersion: string, roleViewModel?: RoleViewModel, options?: any) {
        return AccountApiFp(this.configuration).apiAccountRolesIdPut(id, apiVersion, roleViewModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name 
     * @param {string} apiVersion The requested API version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public apiAccountRolesNameNameGet(name: string, apiVersion: string, options?: any) {
        return AccountApiFp(this.configuration).apiAccountRolesNameNameGet(name, apiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} pageNumber 
     * @param {number} pageSize 
     * @param {string} apiVersion The requested API version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public apiAccountRolesPageNumberPageSizeGet(pageNumber: number, pageSize: number, apiVersion: string, options?: any) {
        return AccountApiFp(this.configuration).apiAccountRolesPageNumberPageSizeGet(pageNumber, pageSize, apiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {RoleViewModel} [roleViewModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public apiAccountRolesPost(apiVersion: string, roleViewModel?: RoleViewModel, options?: any) {
        return AccountApiFp(this.configuration).apiAccountRolesPost(apiVersion, roleViewModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public apiAccountUsersGet(apiVersion: string, options?: any) {
        return AccountApiFp(this.configuration).apiAccountUsersGet(apiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} apiVersion The requested API version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public apiAccountUsersIdDelete(id: string, apiVersion: string, options?: any) {
        return AccountApiFp(this.configuration).apiAccountUsersIdDelete(id, apiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} apiVersion The requested API version
     * @param {UserPatchViewModelJsonPatchDocument} [userPatchViewModelJsonPatchDocument] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public apiAccountUsersIdPatch(id: string, apiVersion: string, userPatchViewModelJsonPatchDocument?: UserPatchViewModelJsonPatchDocument, options?: any) {
        return AccountApiFp(this.configuration).apiAccountUsersIdPatch(id, apiVersion, userPatchViewModelJsonPatchDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} apiVersion The requested API version
     * @param {UserEditViewModel} [userEditViewModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public apiAccountUsersIdPut(id: string, apiVersion: string, userEditViewModel?: UserEditViewModel, options?: any) {
        return AccountApiFp(this.configuration).apiAccountUsersIdPut(id, apiVersion, userEditViewModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public apiAccountUsersMeGet(apiVersion: string, options?: any) {
        return AccountApiFp(this.configuration).apiAccountUsersMeGet(apiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {UserPatchViewModelJsonPatchDocument} [userPatchViewModelJsonPatchDocument] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public apiAccountUsersMePatch(apiVersion: string, userPatchViewModelJsonPatchDocument?: UserPatchViewModelJsonPatchDocument, options?: any) {
        return AccountApiFp(this.configuration).apiAccountUsersMePatch(apiVersion, userPatchViewModelJsonPatchDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public apiAccountUsersMePreferencesGet(apiVersion: string, options?: any) {
        return AccountApiFp(this.configuration).apiAccountUsersMePreferencesGet(apiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {string} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public apiAccountUsersMePreferencesPut(apiVersion: string, body?: string, options?: any) {
        return AccountApiFp(this.configuration).apiAccountUsersMePreferencesPut(apiVersion, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {UserEditViewModel} [userEditViewModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public apiAccountUsersMePut(apiVersion: string, userEditViewModel?: UserEditViewModel, options?: any) {
        return AccountApiFp(this.configuration).apiAccountUsersMePut(apiVersion, userEditViewModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} pageNumber 
     * @param {number} pageSize 
     * @param {string} apiVersion The requested API version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public apiAccountUsersPageNumberPageSizeGet(pageNumber: number, pageSize: number, apiVersion: string, options?: any) {
        return AccountApiFp(this.configuration).apiAccountUsersPageNumberPageSizeGet(pageNumber, pageSize, apiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {UserEditViewModel} [userEditViewModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public apiAccountUsersPost(apiVersion: string, userEditViewModel?: UserEditViewModel, options?: any) {
        return AccountApiFp(this.configuration).apiAccountUsersPost(apiVersion, userEditViewModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} apiVersion The requested API version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public apiAccountUsersUnblockIdPut(id: string, apiVersion: string, options?: any) {
        return AccountApiFp(this.configuration).apiAccountUsersUnblockIdPut(id, apiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userName 
     * @param {string} apiVersion The requested API version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public apiAccountUsersUsernameUserNameGet(userName: string, apiVersion: string, options?: any) {
        return AccountApiFp(this.configuration).apiAccountUsersUsernameUserNameGet(userName, apiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} apiVersion The requested API version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getRoleById(id: string, apiVersion: string, options?: any) {
        return AccountApiFp(this.configuration).getRoleById(id, apiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} apiVersion The requested API version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getUserById(id: string, apiVersion: string, options?: any) {
        return AccountApiFp(this.configuration).getUserById(id, apiVersion, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccountAccessApi - axios parameter creator
 * @export
 */
export const AccountAccessApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessAccessDeniedGet: async (apiVersion: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling accountAccessAccessDeniedGet.');
            }
            const localVarPath = `/AccountAccess/AccessDenied`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [userId] 
         * @param {string} [code] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessConfirmEmailGet: async (apiVersion: string, userId?: string, code?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling accountAccessConfirmEmailGet.');
            }
            const localVarPath = `/AccountAccess/ConfirmEmail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [returnUrl] 
         * @param {string} [remoteError] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessExternalLoginCallbackGet: async (apiVersion: string, returnUrl?: string, remoteError?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling accountAccessExternalLoginCallbackGet.');
            }
            const localVarPath = `/AccountAccess/ExternalLoginCallback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (returnUrl !== undefined) {
                localVarQueryParameter['returnUrl'] = returnUrl;
            }

            if (remoteError !== undefined) {
                localVarQueryParameter['remoteError'] = remoteError;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [returnUrl] 
         * @param {ExternalLoginViewModel} [externalLoginViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessExternalLoginConfirmationPost: async (apiVersion: string, returnUrl?: string, externalLoginViewModel?: ExternalLoginViewModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling accountAccessExternalLoginConfirmationPost.');
            }
            const localVarPath = `/AccountAccess/ExternalLoginConfirmation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (returnUrl !== undefined) {
                localVarQueryParameter['returnUrl'] = returnUrl;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof externalLoginViewModel !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(externalLoginViewModel !== undefined ? externalLoginViewModel : {})
                : (externalLoginViewModel || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [provider] 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessExternalLoginPost: async (apiVersion: string, provider?: string, returnUrl?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling accountAccessExternalLoginPost.');
            }
            const localVarPath = `/AccountAccess/ExternalLogin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            if (returnUrl !== undefined) {
                localVarQueryParameter['returnUrl'] = returnUrl;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessForgotPasswordConfirmationGet: async (apiVersion: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling accountAccessForgotPasswordConfirmationGet.');
            }
            const localVarPath = `/AccountAccess/ForgotPasswordConfirmation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessForgotPasswordGet: async (apiVersion: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling accountAccessForgotPasswordGet.');
            }
            const localVarPath = `/AccountAccess/ForgotPassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessLockoutGet: async (apiVersion: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling accountAccessLockoutGet.');
            }
            const localVarPath = `/AccountAccess/Lockout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessLoginGet: async (apiVersion: string, returnUrl?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling accountAccessLoginGet.');
            }
            const localVarPath = `/AccountAccess/Login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (returnUrl !== undefined) {
                localVarQueryParameter['returnUrl'] = returnUrl;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {boolean} [rememberMe] 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessLoginWith2faGet: async (apiVersion: string, rememberMe?: boolean, returnUrl?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling accountAccessLoginWith2faGet.');
            }
            const localVarPath = `/AccountAccess/LoginWith2fa`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (rememberMe !== undefined) {
                localVarQueryParameter['rememberMe'] = rememberMe;
            }

            if (returnUrl !== undefined) {
                localVarQueryParameter['returnUrl'] = returnUrl;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {boolean} [rememberMeInput] 
         * @param {string} [returnUrl] 
         * @param {LoginWith2faViewModel} [loginWith2faViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessLoginWith2faWithReturnUrlPost: async (apiVersion: string, rememberMeInput?: boolean, returnUrl?: string, loginWith2faViewModel?: LoginWith2faViewModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling accountAccessLoginWith2faWithReturnUrlPost.');
            }
            const localVarPath = `/AccountAccess/LoginWith2fa/WithReturnUrl`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (rememberMeInput !== undefined) {
                localVarQueryParameter['rememberMeInput'] = rememberMeInput;
            }

            if (returnUrl !== undefined) {
                localVarQueryParameter['returnUrl'] = returnUrl;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof loginWith2faViewModel !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(loginWith2faViewModel !== undefined ? loginWith2faViewModel : {})
                : (loginWith2faViewModel || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessLoginWithRecoveryCodeGet: async (apiVersion: string, returnUrl?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling accountAccessLoginWithRecoveryCodeGet.');
            }
            const localVarPath = `/AccountAccess/LoginWithRecoveryCode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (returnUrl !== undefined) {
                localVarQueryParameter['returnUrl'] = returnUrl;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [returnUrl] 
         * @param {LoginWithRecoveryCodeViewModel} [loginWithRecoveryCodeViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessLoginWithRecoveryCodeWithReturnUrlPost: async (apiVersion: string, returnUrl?: string, loginWithRecoveryCodeViewModel?: LoginWithRecoveryCodeViewModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling accountAccessLoginWithRecoveryCodeWithReturnUrlPost.');
            }
            const localVarPath = `/AccountAccess/LoginWithRecoveryCode/WithReturnUrl`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (returnUrl !== undefined) {
                localVarQueryParameter['returnUrl'] = returnUrl;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof loginWithRecoveryCodeViewModel !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(loginWithRecoveryCodeViewModel !== undefined ? loginWithRecoveryCodeViewModel : {})
                : (loginWithRecoveryCodeViewModel || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [returnUrl] 
         * @param {LoginViewModel} [loginViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessLoginWithReturnUrlPost: async (apiVersion: string, returnUrl?: string, loginViewModel?: LoginViewModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling accountAccessLoginWithReturnUrlPost.');
            }
            const localVarPath = `/AccountAccess/Login/WithReturnUrl`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (returnUrl !== undefined) {
                localVarQueryParameter['returnUrl'] = returnUrl;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof loginViewModel !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(loginViewModel !== undefined ? loginViewModel : {})
                : (loginViewModel || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessRegisterGet: async (apiVersion: string, returnUrl?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling accountAccessRegisterGet.');
            }
            const localVarPath = `/AccountAccess/Register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (returnUrl !== undefined) {
                localVarQueryParameter['returnUrl'] = returnUrl;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [returnUrl] 
         * @param {boolean} [isHtml] 
         * @param {RegisterViewModel} [registerViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessRegisterPost: async (apiVersion: string, returnUrl?: string, isHtml?: boolean, registerViewModel?: RegisterViewModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling accountAccessRegisterPost.');
            }
            const localVarPath = `/AccountAccess/Register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (returnUrl !== undefined) {
                localVarQueryParameter['returnUrl'] = returnUrl;
            }

            if (isHtml !== undefined) {
                localVarQueryParameter['isHtml'] = isHtml;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof registerViewModel !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(registerViewModel !== undefined ? registerViewModel : {})
                : (registerViewModel || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessResetPasswordConfirmationGet: async (apiVersion: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling accountAccessResetPasswordConfirmationGet.');
            }
            const localVarPath = `/AccountAccess/ResetPasswordConfirmation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [code] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessResetPasswordGet: async (apiVersion: string, code?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling accountAccessResetPasswordGet.');
            }
            const localVarPath = `/AccountAccess/ResetPassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {ResetPasswordViewModel} [resetPasswordViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessResetPasswordPost: async (apiVersion: string, resetPasswordViewModel?: ResetPasswordViewModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling accountAccessResetPasswordPost.');
            }
            const localVarPath = `/AccountAccess/ResetPassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof resetPasswordViewModel !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(resetPasswordViewModel !== undefined ? resetPasswordViewModel : {})
                : (resetPasswordViewModel || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountAccessApi - functional programming interface
 * @export
 */
export const AccountAccessApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountAccessAccessDeniedGet(apiVersion: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountAccessApiAxiosParamCreator(configuration).accountAccessAccessDeniedGet(apiVersion, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [userId] 
         * @param {string} [code] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountAccessConfirmEmailGet(apiVersion: string, userId?: string, code?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountAccessApiAxiosParamCreator(configuration).accountAccessConfirmEmailGet(apiVersion, userId, code, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [returnUrl] 
         * @param {string} [remoteError] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountAccessExternalLoginCallbackGet(apiVersion: string, returnUrl?: string, remoteError?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountAccessApiAxiosParamCreator(configuration).accountAccessExternalLoginCallbackGet(apiVersion, returnUrl, remoteError, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [returnUrl] 
         * @param {ExternalLoginViewModel} [externalLoginViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountAccessExternalLoginConfirmationPost(apiVersion: string, returnUrl?: string, externalLoginViewModel?: ExternalLoginViewModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountAccessApiAxiosParamCreator(configuration).accountAccessExternalLoginConfirmationPost(apiVersion, returnUrl, externalLoginViewModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [provider] 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountAccessExternalLoginPost(apiVersion: string, provider?: string, returnUrl?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountAccessApiAxiosParamCreator(configuration).accountAccessExternalLoginPost(apiVersion, provider, returnUrl, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountAccessForgotPasswordConfirmationGet(apiVersion: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountAccessApiAxiosParamCreator(configuration).accountAccessForgotPasswordConfirmationGet(apiVersion, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountAccessForgotPasswordGet(apiVersion: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountAccessApiAxiosParamCreator(configuration).accountAccessForgotPasswordGet(apiVersion, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountAccessLockoutGet(apiVersion: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountAccessApiAxiosParamCreator(configuration).accountAccessLockoutGet(apiVersion, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountAccessLoginGet(apiVersion: string, returnUrl?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountAccessApiAxiosParamCreator(configuration).accountAccessLoginGet(apiVersion, returnUrl, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {boolean} [rememberMe] 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountAccessLoginWith2faGet(apiVersion: string, rememberMe?: boolean, returnUrl?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountAccessApiAxiosParamCreator(configuration).accountAccessLoginWith2faGet(apiVersion, rememberMe, returnUrl, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {boolean} [rememberMeInput] 
         * @param {string} [returnUrl] 
         * @param {LoginWith2faViewModel} [loginWith2faViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountAccessLoginWith2faWithReturnUrlPost(apiVersion: string, rememberMeInput?: boolean, returnUrl?: string, loginWith2faViewModel?: LoginWith2faViewModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountAccessApiAxiosParamCreator(configuration).accountAccessLoginWith2faWithReturnUrlPost(apiVersion, rememberMeInput, returnUrl, loginWith2faViewModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountAccessLoginWithRecoveryCodeGet(apiVersion: string, returnUrl?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountAccessApiAxiosParamCreator(configuration).accountAccessLoginWithRecoveryCodeGet(apiVersion, returnUrl, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [returnUrl] 
         * @param {LoginWithRecoveryCodeViewModel} [loginWithRecoveryCodeViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountAccessLoginWithRecoveryCodeWithReturnUrlPost(apiVersion: string, returnUrl?: string, loginWithRecoveryCodeViewModel?: LoginWithRecoveryCodeViewModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountAccessApiAxiosParamCreator(configuration).accountAccessLoginWithRecoveryCodeWithReturnUrlPost(apiVersion, returnUrl, loginWithRecoveryCodeViewModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [returnUrl] 
         * @param {LoginViewModel} [loginViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountAccessLoginWithReturnUrlPost(apiVersion: string, returnUrl?: string, loginViewModel?: LoginViewModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountAccessApiAxiosParamCreator(configuration).accountAccessLoginWithReturnUrlPost(apiVersion, returnUrl, loginViewModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountAccessRegisterGet(apiVersion: string, returnUrl?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountAccessApiAxiosParamCreator(configuration).accountAccessRegisterGet(apiVersion, returnUrl, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [returnUrl] 
         * @param {boolean} [isHtml] 
         * @param {RegisterViewModel} [registerViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountAccessRegisterPost(apiVersion: string, returnUrl?: string, isHtml?: boolean, registerViewModel?: RegisterViewModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountAccessApiAxiosParamCreator(configuration).accountAccessRegisterPost(apiVersion, returnUrl, isHtml, registerViewModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountAccessResetPasswordConfirmationGet(apiVersion: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountAccessApiAxiosParamCreator(configuration).accountAccessResetPasswordConfirmationGet(apiVersion, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [code] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountAccessResetPasswordGet(apiVersion: string, code?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountAccessApiAxiosParamCreator(configuration).accountAccessResetPasswordGet(apiVersion, code, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {ResetPasswordViewModel} [resetPasswordViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountAccessResetPasswordPost(apiVersion: string, resetPasswordViewModel?: ResetPasswordViewModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountAccessApiAxiosParamCreator(configuration).accountAccessResetPasswordPost(apiVersion, resetPasswordViewModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AccountAccessApi - factory interface
 * @export
 */
export const AccountAccessApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessAccessDeniedGet(apiVersion: string, options?: any): AxiosPromise<void> {
            return AccountAccessApiFp(configuration).accountAccessAccessDeniedGet(apiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [userId] 
         * @param {string} [code] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessConfirmEmailGet(apiVersion: string, userId?: string, code?: string, options?: any): AxiosPromise<void> {
            return AccountAccessApiFp(configuration).accountAccessConfirmEmailGet(apiVersion, userId, code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [returnUrl] 
         * @param {string} [remoteError] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessExternalLoginCallbackGet(apiVersion: string, returnUrl?: string, remoteError?: string, options?: any): AxiosPromise<void> {
            return AccountAccessApiFp(configuration).accountAccessExternalLoginCallbackGet(apiVersion, returnUrl, remoteError, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [returnUrl] 
         * @param {ExternalLoginViewModel} [externalLoginViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessExternalLoginConfirmationPost(apiVersion: string, returnUrl?: string, externalLoginViewModel?: ExternalLoginViewModel, options?: any): AxiosPromise<void> {
            return AccountAccessApiFp(configuration).accountAccessExternalLoginConfirmationPost(apiVersion, returnUrl, externalLoginViewModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [provider] 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessExternalLoginPost(apiVersion: string, provider?: string, returnUrl?: string, options?: any): AxiosPromise<void> {
            return AccountAccessApiFp(configuration).accountAccessExternalLoginPost(apiVersion, provider, returnUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessForgotPasswordConfirmationGet(apiVersion: string, options?: any): AxiosPromise<void> {
            return AccountAccessApiFp(configuration).accountAccessForgotPasswordConfirmationGet(apiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessForgotPasswordGet(apiVersion: string, options?: any): AxiosPromise<void> {
            return AccountAccessApiFp(configuration).accountAccessForgotPasswordGet(apiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessLockoutGet(apiVersion: string, options?: any): AxiosPromise<void> {
            return AccountAccessApiFp(configuration).accountAccessLockoutGet(apiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessLoginGet(apiVersion: string, returnUrl?: string, options?: any): AxiosPromise<void> {
            return AccountAccessApiFp(configuration).accountAccessLoginGet(apiVersion, returnUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {boolean} [rememberMe] 
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessLoginWith2faGet(apiVersion: string, rememberMe?: boolean, returnUrl?: string, options?: any): AxiosPromise<void> {
            return AccountAccessApiFp(configuration).accountAccessLoginWith2faGet(apiVersion, rememberMe, returnUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {boolean} [rememberMeInput] 
         * @param {string} [returnUrl] 
         * @param {LoginWith2faViewModel} [loginWith2faViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessLoginWith2faWithReturnUrlPost(apiVersion: string, rememberMeInput?: boolean, returnUrl?: string, loginWith2faViewModel?: LoginWith2faViewModel, options?: any): AxiosPromise<void> {
            return AccountAccessApiFp(configuration).accountAccessLoginWith2faWithReturnUrlPost(apiVersion, rememberMeInput, returnUrl, loginWith2faViewModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessLoginWithRecoveryCodeGet(apiVersion: string, returnUrl?: string, options?: any): AxiosPromise<void> {
            return AccountAccessApiFp(configuration).accountAccessLoginWithRecoveryCodeGet(apiVersion, returnUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [returnUrl] 
         * @param {LoginWithRecoveryCodeViewModel} [loginWithRecoveryCodeViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessLoginWithRecoveryCodeWithReturnUrlPost(apiVersion: string, returnUrl?: string, loginWithRecoveryCodeViewModel?: LoginWithRecoveryCodeViewModel, options?: any): AxiosPromise<void> {
            return AccountAccessApiFp(configuration).accountAccessLoginWithRecoveryCodeWithReturnUrlPost(apiVersion, returnUrl, loginWithRecoveryCodeViewModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [returnUrl] 
         * @param {LoginViewModel} [loginViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessLoginWithReturnUrlPost(apiVersion: string, returnUrl?: string, loginViewModel?: LoginViewModel, options?: any): AxiosPromise<void> {
            return AccountAccessApiFp(configuration).accountAccessLoginWithReturnUrlPost(apiVersion, returnUrl, loginViewModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [returnUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessRegisterGet(apiVersion: string, returnUrl?: string, options?: any): AxiosPromise<void> {
            return AccountAccessApiFp(configuration).accountAccessRegisterGet(apiVersion, returnUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [returnUrl] 
         * @param {boolean} [isHtml] 
         * @param {RegisterViewModel} [registerViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessRegisterPost(apiVersion: string, returnUrl?: string, isHtml?: boolean, registerViewModel?: RegisterViewModel, options?: any): AxiosPromise<void> {
            return AccountAccessApiFp(configuration).accountAccessRegisterPost(apiVersion, returnUrl, isHtml, registerViewModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessResetPasswordConfirmationGet(apiVersion: string, options?: any): AxiosPromise<void> {
            return AccountAccessApiFp(configuration).accountAccessResetPasswordConfirmationGet(apiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {string} [code] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessResetPasswordGet(apiVersion: string, code?: string, options?: any): AxiosPromise<void> {
            return AccountAccessApiFp(configuration).accountAccessResetPasswordGet(apiVersion, code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {ResetPasswordViewModel} [resetPasswordViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAccessResetPasswordPost(apiVersion: string, resetPasswordViewModel?: ResetPasswordViewModel, options?: any): AxiosPromise<void> {
            return AccountAccessApiFp(configuration).accountAccessResetPasswordPost(apiVersion, resetPasswordViewModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountAccessApi - object-oriented interface
 * @export
 * @class AccountAccessApi
 * @extends {BaseAPI}
 */
export class AccountAccessApi extends BaseAPI {
    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountAccessApi
     */
    public accountAccessAccessDeniedGet(apiVersion: string, options?: any) {
        return AccountAccessApiFp(this.configuration).accountAccessAccessDeniedGet(apiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {string} [userId] 
     * @param {string} [code] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountAccessApi
     */
    public accountAccessConfirmEmailGet(apiVersion: string, userId?: string, code?: string, options?: any) {
        return AccountAccessApiFp(this.configuration).accountAccessConfirmEmailGet(apiVersion, userId, code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {string} [returnUrl] 
     * @param {string} [remoteError] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountAccessApi
     */
    public accountAccessExternalLoginCallbackGet(apiVersion: string, returnUrl?: string, remoteError?: string, options?: any) {
        return AccountAccessApiFp(this.configuration).accountAccessExternalLoginCallbackGet(apiVersion, returnUrl, remoteError, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {string} [returnUrl] 
     * @param {ExternalLoginViewModel} [externalLoginViewModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountAccessApi
     */
    public accountAccessExternalLoginConfirmationPost(apiVersion: string, returnUrl?: string, externalLoginViewModel?: ExternalLoginViewModel, options?: any) {
        return AccountAccessApiFp(this.configuration).accountAccessExternalLoginConfirmationPost(apiVersion, returnUrl, externalLoginViewModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {string} [provider] 
     * @param {string} [returnUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountAccessApi
     */
    public accountAccessExternalLoginPost(apiVersion: string, provider?: string, returnUrl?: string, options?: any) {
        return AccountAccessApiFp(this.configuration).accountAccessExternalLoginPost(apiVersion, provider, returnUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountAccessApi
     */
    public accountAccessForgotPasswordConfirmationGet(apiVersion: string, options?: any) {
        return AccountAccessApiFp(this.configuration).accountAccessForgotPasswordConfirmationGet(apiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountAccessApi
     */
    public accountAccessForgotPasswordGet(apiVersion: string, options?: any) {
        return AccountAccessApiFp(this.configuration).accountAccessForgotPasswordGet(apiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountAccessApi
     */
    public accountAccessLockoutGet(apiVersion: string, options?: any) {
        return AccountAccessApiFp(this.configuration).accountAccessLockoutGet(apiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {string} [returnUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountAccessApi
     */
    public accountAccessLoginGet(apiVersion: string, returnUrl?: string, options?: any) {
        return AccountAccessApiFp(this.configuration).accountAccessLoginGet(apiVersion, returnUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {boolean} [rememberMe] 
     * @param {string} [returnUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountAccessApi
     */
    public accountAccessLoginWith2faGet(apiVersion: string, rememberMe?: boolean, returnUrl?: string, options?: any) {
        return AccountAccessApiFp(this.configuration).accountAccessLoginWith2faGet(apiVersion, rememberMe, returnUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {boolean} [rememberMeInput] 
     * @param {string} [returnUrl] 
     * @param {LoginWith2faViewModel} [loginWith2faViewModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountAccessApi
     */
    public accountAccessLoginWith2faWithReturnUrlPost(apiVersion: string, rememberMeInput?: boolean, returnUrl?: string, loginWith2faViewModel?: LoginWith2faViewModel, options?: any) {
        return AccountAccessApiFp(this.configuration).accountAccessLoginWith2faWithReturnUrlPost(apiVersion, rememberMeInput, returnUrl, loginWith2faViewModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {string} [returnUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountAccessApi
     */
    public accountAccessLoginWithRecoveryCodeGet(apiVersion: string, returnUrl?: string, options?: any) {
        return AccountAccessApiFp(this.configuration).accountAccessLoginWithRecoveryCodeGet(apiVersion, returnUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {string} [returnUrl] 
     * @param {LoginWithRecoveryCodeViewModel} [loginWithRecoveryCodeViewModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountAccessApi
     */
    public accountAccessLoginWithRecoveryCodeWithReturnUrlPost(apiVersion: string, returnUrl?: string, loginWithRecoveryCodeViewModel?: LoginWithRecoveryCodeViewModel, options?: any) {
        return AccountAccessApiFp(this.configuration).accountAccessLoginWithRecoveryCodeWithReturnUrlPost(apiVersion, returnUrl, loginWithRecoveryCodeViewModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {string} [returnUrl] 
     * @param {LoginViewModel} [loginViewModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountAccessApi
     */
    public accountAccessLoginWithReturnUrlPost(apiVersion: string, returnUrl?: string, loginViewModel?: LoginViewModel, options?: any) {
        return AccountAccessApiFp(this.configuration).accountAccessLoginWithReturnUrlPost(apiVersion, returnUrl, loginViewModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {string} [returnUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountAccessApi
     */
    public accountAccessRegisterGet(apiVersion: string, returnUrl?: string, options?: any) {
        return AccountAccessApiFp(this.configuration).accountAccessRegisterGet(apiVersion, returnUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {string} [returnUrl] 
     * @param {boolean} [isHtml] 
     * @param {RegisterViewModel} [registerViewModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountAccessApi
     */
    public accountAccessRegisterPost(apiVersion: string, returnUrl?: string, isHtml?: boolean, registerViewModel?: RegisterViewModel, options?: any) {
        return AccountAccessApiFp(this.configuration).accountAccessRegisterPost(apiVersion, returnUrl, isHtml, registerViewModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountAccessApi
     */
    public accountAccessResetPasswordConfirmationGet(apiVersion: string, options?: any) {
        return AccountAccessApiFp(this.configuration).accountAccessResetPasswordConfirmationGet(apiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {string} [code] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountAccessApi
     */
    public accountAccessResetPasswordGet(apiVersion: string, code?: string, options?: any) {
        return AccountAccessApiFp(this.configuration).accountAccessResetPasswordGet(apiVersion, code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {ResetPasswordViewModel} [resetPasswordViewModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountAccessApi
     */
    public accountAccessResetPasswordPost(apiVersion: string, resetPasswordViewModel?: ResetPasswordViewModel, options?: any) {
        return AccountAccessApiFp(this.configuration).accountAccessResetPasswordPost(apiVersion, resetPasswordViewModel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccountApplicationApi - axios parameter creator
 * @export
 */
export const AccountApplicationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountApplicationApplicationClientIdDelete: async (id: number, apiVersion: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiAccountApplicationApplicationClientIdDelete.');
            }
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling apiAccountApplicationApplicationClientIdDelete.');
            }
            const localVarPath = `/api/AccountApplication/ApplicationClient/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} apiVersion The requested API version
         * @param {ApplicationClientViewModel} [applicationClientViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountApplicationApplicationClientIdPut: async (id: number, apiVersion: string, applicationClientViewModel?: ApplicationClientViewModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiAccountApplicationApplicationClientIdPut.');
            }
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling apiAccountApplicationApplicationClientIdPut.');
            }
            const localVarPath = `/api/AccountApplication/ApplicationClient/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof applicationClientViewModel !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(applicationClientViewModel !== undefined ? applicationClientViewModel : {})
                : (applicationClientViewModel || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {AddApplicationClientViewModel} [addApplicationClientViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountApplicationApplicationClientPost: async (apiVersion: string, addApplicationClientViewModel?: AddApplicationClientViewModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling apiAccountApplicationApplicationClientPost.');
            }
            const localVarPath = `/api/AccountApplication/ApplicationClient`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof addApplicationClientViewModel !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(addApplicationClientViewModel !== undefined ? addApplicationClientViewModel : {})
                : (addApplicationClientViewModel || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountApplicationApplicationClientUserMapIdDelete: async (id: number, apiVersion: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiAccountApplicationApplicationClientUserMapIdDelete.');
            }
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling apiAccountApplicationApplicationClientUserMapIdDelete.');
            }
            const localVarPath = `/api/AccountApplication/ApplicationClientUserMap/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} apiVersion The requested API version
         * @param {ApplicationClientUserMapViewModel} [applicationClientUserMapViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountApplicationApplicationClientUserMapIdPut: async (id: number, apiVersion: string, applicationClientUserMapViewModel?: ApplicationClientUserMapViewModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiAccountApplicationApplicationClientUserMapIdPut.');
            }
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling apiAccountApplicationApplicationClientUserMapIdPut.');
            }
            const localVarPath = `/api/AccountApplication/ApplicationClientUserMap/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof applicationClientUserMapViewModel !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(applicationClientUserMapViewModel !== undefined ? applicationClientUserMapViewModel : {})
                : (applicationClientUserMapViewModel || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {AddApplicationClientUserMapViewModel} [addApplicationClientUserMapViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountApplicationApplicationClientUserMapPost: async (apiVersion: string, addApplicationClientUserMapViewModel?: AddApplicationClientUserMapViewModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling apiAccountApplicationApplicationClientUserMapPost.');
            }
            const localVarPath = `/api/AccountApplication/ApplicationClientUserMap`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof addApplicationClientUserMapViewModel !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(addApplicationClientUserMapViewModel !== undefined ? addApplicationClientUserMapViewModel : {})
                : (addApplicationClientUserMapViewModel || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountApplicationApplicationClientUserMapValuesGet: async (apiVersion: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling apiAccountApplicationApplicationClientUserMapValuesGet.');
            }
            const localVarPath = `/api/AccountApplication/ApplicationClientUserMapValues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountApplicationApplicationClientValuesGet: async (apiVersion: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling apiAccountApplicationApplicationClientValuesGet.');
            }
            const localVarPath = `/api/AccountApplication/ApplicationClientValues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationClient: async (id: number, apiVersion: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getApplicationClient.');
            }
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling getApplicationClient.');
            }
            const localVarPath = `/api/AccountApplication/ApplicationClient/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationClientUserMap: async (id: number, apiVersion: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getApplicationClientUserMap.');
            }
            // verify required parameter 'apiVersion' is not null or undefined
            if (apiVersion === null || apiVersion === undefined) {
                throw new RequiredError('apiVersion','Required parameter apiVersion was null or undefined when calling getApplicationClientUserMap.');
            }
            const localVarPath = `/api/AccountApplication/ApplicationClientUserMap/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("oauth2", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApplicationApi - functional programming interface
 * @export
 */
export const AccountApplicationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountApplicationApplicationClientIdDelete(id: number, apiVersion: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationClientViewModel>> {
            const localVarAxiosArgs = await AccountApplicationApiAxiosParamCreator(configuration).apiAccountApplicationApplicationClientIdDelete(id, apiVersion, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} apiVersion The requested API version
         * @param {ApplicationClientViewModel} [applicationClientViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountApplicationApplicationClientIdPut(id: number, apiVersion: string, applicationClientViewModel?: ApplicationClientViewModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApplicationClientViewModel>>> {
            const localVarAxiosArgs = await AccountApplicationApiAxiosParamCreator(configuration).apiAccountApplicationApplicationClientIdPut(id, apiVersion, applicationClientViewModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {AddApplicationClientViewModel} [addApplicationClientViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountApplicationApplicationClientPost(apiVersion: string, addApplicationClientViewModel?: AddApplicationClientViewModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationClientViewModel>> {
            const localVarAxiosArgs = await AccountApplicationApiAxiosParamCreator(configuration).apiAccountApplicationApplicationClientPost(apiVersion, addApplicationClientViewModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountApplicationApplicationClientUserMapIdDelete(id: number, apiVersion: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationClientUserMapViewModel>> {
            const localVarAxiosArgs = await AccountApplicationApiAxiosParamCreator(configuration).apiAccountApplicationApplicationClientUserMapIdDelete(id, apiVersion, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} apiVersion The requested API version
         * @param {ApplicationClientUserMapViewModel} [applicationClientUserMapViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountApplicationApplicationClientUserMapIdPut(id: number, apiVersion: string, applicationClientUserMapViewModel?: ApplicationClientUserMapViewModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApplicationClientUserMapViewModel>>> {
            const localVarAxiosArgs = await AccountApplicationApiAxiosParamCreator(configuration).apiAccountApplicationApplicationClientUserMapIdPut(id, apiVersion, applicationClientUserMapViewModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {AddApplicationClientUserMapViewModel} [addApplicationClientUserMapViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountApplicationApplicationClientUserMapPost(apiVersion: string, addApplicationClientUserMapViewModel?: AddApplicationClientUserMapViewModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationClientUserMapViewModel>> {
            const localVarAxiosArgs = await AccountApplicationApiAxiosParamCreator(configuration).apiAccountApplicationApplicationClientUserMapPost(apiVersion, addApplicationClientUserMapViewModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountApplicationApplicationClientUserMapValuesGet(apiVersion: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApplicationClientUserMapViewModel>>> {
            const localVarAxiosArgs = await AccountApplicationApiAxiosParamCreator(configuration).apiAccountApplicationApplicationClientUserMapValuesGet(apiVersion, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountApplicationApplicationClientValuesGet(apiVersion: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApplicationClientViewModel>>> {
            const localVarAxiosArgs = await AccountApplicationApiAxiosParamCreator(configuration).apiAccountApplicationApplicationClientValuesGet(apiVersion, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationClient(id: number, apiVersion: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationClientViewModel>> {
            const localVarAxiosArgs = await AccountApplicationApiAxiosParamCreator(configuration).getApplicationClient(id, apiVersion, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationClientUserMap(id: number, apiVersion: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationClientUserMapViewModel>> {
            const localVarAxiosArgs = await AccountApplicationApiAxiosParamCreator(configuration).getApplicationClientUserMap(id, apiVersion, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AccountApplicationApi - factory interface
 * @export
 */
export const AccountApplicationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountApplicationApplicationClientIdDelete(id: number, apiVersion: string, options?: any): AxiosPromise<ApplicationClientViewModel> {
            return AccountApplicationApiFp(configuration).apiAccountApplicationApplicationClientIdDelete(id, apiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {string} apiVersion The requested API version
         * @param {ApplicationClientViewModel} [applicationClientViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountApplicationApplicationClientIdPut(id: number, apiVersion: string, applicationClientViewModel?: ApplicationClientViewModel, options?: any): AxiosPromise<Array<ApplicationClientViewModel>> {
            return AccountApplicationApiFp(configuration).apiAccountApplicationApplicationClientIdPut(id, apiVersion, applicationClientViewModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {AddApplicationClientViewModel} [addApplicationClientViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountApplicationApplicationClientPost(apiVersion: string, addApplicationClientViewModel?: AddApplicationClientViewModel, options?: any): AxiosPromise<ApplicationClientViewModel> {
            return AccountApplicationApiFp(configuration).apiAccountApplicationApplicationClientPost(apiVersion, addApplicationClientViewModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountApplicationApplicationClientUserMapIdDelete(id: number, apiVersion: string, options?: any): AxiosPromise<ApplicationClientUserMapViewModel> {
            return AccountApplicationApiFp(configuration).apiAccountApplicationApplicationClientUserMapIdDelete(id, apiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {string} apiVersion The requested API version
         * @param {ApplicationClientUserMapViewModel} [applicationClientUserMapViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountApplicationApplicationClientUserMapIdPut(id: number, apiVersion: string, applicationClientUserMapViewModel?: ApplicationClientUserMapViewModel, options?: any): AxiosPromise<Array<ApplicationClientUserMapViewModel>> {
            return AccountApplicationApiFp(configuration).apiAccountApplicationApplicationClientUserMapIdPut(id, apiVersion, applicationClientUserMapViewModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {AddApplicationClientUserMapViewModel} [addApplicationClientUserMapViewModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountApplicationApplicationClientUserMapPost(apiVersion: string, addApplicationClientUserMapViewModel?: AddApplicationClientUserMapViewModel, options?: any): AxiosPromise<ApplicationClientUserMapViewModel> {
            return AccountApplicationApiFp(configuration).apiAccountApplicationApplicationClientUserMapPost(apiVersion, addApplicationClientUserMapViewModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountApplicationApplicationClientUserMapValuesGet(apiVersion: string, options?: any): AxiosPromise<Array<ApplicationClientUserMapViewModel>> {
            return AccountApplicationApiFp(configuration).apiAccountApplicationApplicationClientUserMapValuesGet(apiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountApplicationApplicationClientValuesGet(apiVersion: string, options?: any): AxiosPromise<Array<ApplicationClientViewModel>> {
            return AccountApplicationApiFp(configuration).apiAccountApplicationApplicationClientValuesGet(apiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationClient(id: number, apiVersion: string, options?: any): AxiosPromise<ApplicationClientViewModel> {
            return AccountApplicationApiFp(configuration).getApplicationClient(id, apiVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {string} apiVersion The requested API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationClientUserMap(id: number, apiVersion: string, options?: any): AxiosPromise<ApplicationClientUserMapViewModel> {
            return AccountApplicationApiFp(configuration).getApplicationClientUserMap(id, apiVersion, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountApplicationApi - object-oriented interface
 * @export
 * @class AccountApplicationApi
 * @extends {BaseAPI}
 */
export class AccountApplicationApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {string} apiVersion The requested API version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApplicationApi
     */
    public apiAccountApplicationApplicationClientIdDelete(id: number, apiVersion: string, options?: any) {
        return AccountApplicationApiFp(this.configuration).apiAccountApplicationApplicationClientIdDelete(id, apiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {string} apiVersion The requested API version
     * @param {ApplicationClientViewModel} [applicationClientViewModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApplicationApi
     */
    public apiAccountApplicationApplicationClientIdPut(id: number, apiVersion: string, applicationClientViewModel?: ApplicationClientViewModel, options?: any) {
        return AccountApplicationApiFp(this.configuration).apiAccountApplicationApplicationClientIdPut(id, apiVersion, applicationClientViewModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {AddApplicationClientViewModel} [addApplicationClientViewModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApplicationApi
     */
    public apiAccountApplicationApplicationClientPost(apiVersion: string, addApplicationClientViewModel?: AddApplicationClientViewModel, options?: any) {
        return AccountApplicationApiFp(this.configuration).apiAccountApplicationApplicationClientPost(apiVersion, addApplicationClientViewModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {string} apiVersion The requested API version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApplicationApi
     */
    public apiAccountApplicationApplicationClientUserMapIdDelete(id: number, apiVersion: string, options?: any) {
        return AccountApplicationApiFp(this.configuration).apiAccountApplicationApplicationClientUserMapIdDelete(id, apiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {string} apiVersion The requested API version
     * @param {ApplicationClientUserMapViewModel} [applicationClientUserMapViewModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApplicationApi
     */
    public apiAccountApplicationApplicationClientUserMapIdPut(id: number, apiVersion: string, applicationClientUserMapViewModel?: ApplicationClientUserMapViewModel, options?: any) {
        return AccountApplicationApiFp(this.configuration).apiAccountApplicationApplicationClientUserMapIdPut(id, apiVersion, applicationClientUserMapViewModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {AddApplicationClientUserMapViewModel} [addApplicationClientUserMapViewModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApplicationApi
     */
    public apiAccountApplicationApplicationClientUserMapPost(apiVersion: string, addApplicationClientUserMapViewModel?: AddApplicationClientUserMapViewModel, options?: any) {
        return AccountApplicationApiFp(this.configuration).apiAccountApplicationApplicationClientUserMapPost(apiVersion, addApplicationClientUserMapViewModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApplicationApi
     */
    public apiAccountApplicationApplicationClientUserMapValuesGet(apiVersion: string, options?: any) {
        return AccountApplicationApiFp(this.configuration).apiAccountApplicationApplicationClientUserMapValuesGet(apiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} apiVersion The requested API version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApplicationApi
     */
    public apiAccountApplicationApplicationClientValuesGet(apiVersion: string, options?: any) {
        return AccountApplicationApiFp(this.configuration).apiAccountApplicationApplicationClientValuesGet(apiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {string} apiVersion The requested API version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApplicationApi
     */
    public getApplicationClient(id: number, apiVersion: string, options?: any) {
        return AccountApplicationApiFp(this.configuration).getApplicationClient(id, apiVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {string} apiVersion The requested API version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApplicationApi
     */
    public getApplicationClientUserMap(id: number, apiVersion: string, options?: any) {
        return AccountApplicationApiFp(this.configuration).getApplicationClientUserMap(id, apiVersion, options).then((request) => request(this.axios, this.basePath));
    }
}


